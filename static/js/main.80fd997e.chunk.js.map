{"version":3,"sources":["util/createScreen.js","screen/system/DeadlineRenderSystem.js","util/parallaxCalculator.js","screen/system/BgRenderSystem.js","screen/system/ParticleSystem.js","screen/system/WallSystem.js","screen/system/WallRenderSystem.js","screen/system/PlayerRenderSystem.js","screen/system/ObstacleSystem.js","screen/system/ObstacleRenderSystem.js","screen/system/DebuffRenderSystem.js","screen/system/WatchSystem.js","screen/system/WatchRenderSystem.js","screen/testScreen.js","index.js"],"names":["noop","createScreen","update","destroy","createDeadlineRenderSystem","width","height","deadLineAtlas","batch","deadlineBackGradient","findRegion","deadlineFrontGradient","singleNote","singlePaper","deadlineBase","singlePaperStackFrame","paperStackAnimation","createAnimation","findRegions","PARTICLE_SIZE","BG_WIDTH","BACK_GRADIENT_HEIGHT","BACK_GRADIENT_Y","BASE_HEIGHT","BASE_Y","FRONT_GRADIENT_HEIGHT","FRONT_GRADIENT_Y","PAPER_STACK_WIDTH","PAPER_STACK_HEIGHT","PAPER_STACK_Y","PAPER_STACK_ANIMATION_DELAY","i","Math","random","deadlineParticleTime","deadLineParticleRate","deadlineParticles","DEADLINE_PARTICLE_SPEED","DEADLINE_PARTICLE_DECELERATOR","setDeadLineParticleRate","rate","getDeadLineParticleRate","delta","stateTime","type","push","x","y","size","speedY","rotation","PI","particle","expired","length","splice","draw","PAPER_STACK_COUNT","getKeyFrame","PlayMode","LOOP_PINGPONG","results","calculateParallaxByOffset","displaySize","texSize","offset","current","startPoint","createBgRenderSystem","bg1","bg2","BG1_HEIGHT","BG2_HEIGHT","gap","drawStarts","drawStart","createParticleSystem","_height","noteTex","PLAYER_SIZE","particles","particleTime","PARTICLE_RANGE","duration","t","alpha","setColor","createWallSystem","wallStarts","obstacles","WALL_LENGTH","WALL_THICKNESS","latestWallStartGenerated","OBSTACLE_SIZE","screenY","floor","wallIndex","obstacleWidth","obstacleHeight","createWallRenderSystem","whiteTex","wallStart","fillRect","createPlayerRenderSystem","characterAtlas","slashAtlas","obstacleAtlas","watchAtlas","gender","outfit","runAnimationName","jumpAnimationName","runFrames","jumpFrames","runAnimation","jumpAnimation","transitionAnimation","slice","slashFrames","slashAnimation","buffAnimation","SLASH_X","SLASH_WIDTH","SLASH_HEIGHT","firstJump","flipped","jumping","jumpStart","buffTime","currentOutfit","transitionTime","console","log","updateOutfit","originX","scaleX","NORMAL","frame","createObstacleSystem","PROJECTILE_SPEED","PROJECTILE_SIZE","tmp","Vector2","obstacle","fired","abs","projectilePos","vel","set","rotateRad","projectileVel","projectileSize","projectileStart","setVector","scale","addVector","OBSTACLE_NAMES","createObstacleRenderSystem","animations","idleAnimations","bulletAnimations","projectileHitAnimation","coinAnimation","frames","hit","projectileHit","projectileHitTime","createDebuffRenderSystem","debuffs","obstacleHitBaseName","OBSTACLE_HIT_TYPE_NAME","sampleFrame","DEBUFF_WIDTH","DEBUFF_HEIGHT","obstacleHitAnimations","regions","debuff","time","offsetY","createWatchSystem","watches","WATCH_SIZE","timeUntilNextWatch","drawX","drawY","drawScale","createWatchRenderSystem","watchAnimations","watch","hitTime","LOOP","createTestScreen","Game","a","gl","canvas","assets","createBatch","camera","createOrthoCamera","createWhiteTex","inputHandler","InputHandler","JUMP_SPEED_X","coinCount","hasBuff","speedX","targetGap","INITIAL_GAP","minX","maxX","jump","addEventListener","document","checkLanding","newX","landing","processPlayerPos","modifier","deltaX","processWatchCollsion","pL","pR","pT","pB","oL","oR","oT","oB","processObstacleCollision","hitted","oWidth","oHeight","pos","deadlineRenderSystem","MAXIMUM_DEADLINE_RATE","OUT_FIT_COIN_REQUIRED","processOutfit","bgRenderSystem","particleSystem","wallSystem","wallRenderSystem","playerRenderSystem","obstacleSystem","obstacleRenderSystem","debuffRenderSystem","watchSystem","watchRenderSystem","setPosition","setProjection","combined","begin","end","cleanup","removeEventListener","getElementById","loading","resizeCanvas","getContext","pixelRatio","setCurrentScreen","screen","currentScreen","count","innerHTML","doAndCount","promise","then","result","Promise","all","loadTexture","loadAtlas","style","display","clearColor","clear","COLOR_BUFFER_BIT","createGameLoop","init"],"mappings":"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","file":"static/js/main.80fd997e.chunk.js","sourcesContent":["const noop = () => {};\n\nconst createScreen = ({ update = noop, destroy = noop }) => {\n  return { update, destroy };\n};\n\nexport default createScreen;\n","import { createAnimation } from 'gdxjs';\nimport { PlayMode } from 'gdxjs/lib/createAnimation';\n\nexport const createDeadlineRenderSystem = (width, height, deadLineAtlas, batch) => {\n  const deadlineBackGradient = deadLineAtlas.findRegion('deadline-back-gradient');\n  const deadlineFrontGradient = deadLineAtlas.findRegion('deadline-front-gradient');\n  const singleNote = deadLineAtlas.findRegion('single-note');\n  const singlePaper = deadLineAtlas.findRegion('single-paper');\n  const deadlineBase = deadLineAtlas.findRegion('deadline-base');\n  const singlePaperStackFrame = deadLineAtlas.findRegion('paper_stack');\n  const paperStackAnimation = createAnimation(0.1, deadLineAtlas.findRegions('paper_stack'));\n\n  const PARTICLE_SIZE = width / 30;\n  const BG_WIDTH = width;\n  const BACK_GRADIENT_HEIGHT = (BG_WIDTH / deadlineBackGradient.width) * deadlineBackGradient.height;\n  const BACK_GRADIENT_Y = height - BACK_GRADIENT_HEIGHT;\n  const BASE_HEIGHT = (BG_WIDTH / deadlineBase.width) * deadlineBase.height;\n  const BASE_Y = height - BASE_HEIGHT / 2;\n  const FRONT_GRADIENT_HEIGHT = (BG_WIDTH / deadlineFrontGradient.width) * deadlineFrontGradient.height;\n  const FRONT_GRADIENT_Y = height - FRONT_GRADIENT_HEIGHT;\n\n  const PAPER_STACK_COUNT = 4;\n  const PAPER_STACK_WIDTH = width / PAPER_STACK_COUNT;\n  const PAPER_STACK_HEIGHT = (PAPER_STACK_WIDTH / singlePaperStackFrame.width) * singlePaperStackFrame.height;\n  const PAPER_STACK_Y = height - PAPER_STACK_HEIGHT;\n  const PAPER_STACK_ANIMATION_DELAY = [];\n  for (let i = 0; i < PAPER_STACK_COUNT; i++) {\n    PAPER_STACK_ANIMATION_DELAY[i] = Math.random() * 0.5;\n  }\n\n  let deadlineParticleTime = 0;\n  let deadLineParticleRate = 0.15;\n  const deadlineParticles = [];\n  const DEADLINE_PARTICLE_SPEED = -height / 2;\n  const DEADLINE_PARTICLE_DECELERATOR = height * 0.75;\n\n  return {\n    setDeadLineParticleRate(rate) {\n      deadLineParticleRate = rate;\n    },\n    getDeadLineParticleRate() {\n      return deadLineParticleRate;\n    },\n    update(delta, stateTime) {\n      deadlineParticleTime += delta;\n      while (deadlineParticleTime >= deadLineParticleRate) {\n        deadlineParticleTime -= deadLineParticleRate;\n        const type = Math.random() > 0.5 ? 0 : 1;\n        deadlineParticles.push({\n          x: Math.random() * width,\n          y: height,\n          size: type === 0 ? PARTICLE_SIZE * 2 : PARTICLE_SIZE,\n          speedY: DEADLINE_PARTICLE_SPEED,\n          type,\n          rotation: (Math.random() * Math.PI) / 2\n        });\n      }\n\n      for (let particle of deadlineParticles) {\n        particle.speedY += DEADLINE_PARTICLE_DECELERATOR * delta;\n        particle.y = particle.y + particle.speedY * delta;\n        if (particle.y > height) {\n          particle.expired = true;\n        }\n      }\n\n      for (let i = deadlineParticles.length - 1; i >= 0; i--) {\n        if (deadlineParticles[i].expired) {\n          deadlineParticles.splice(i, 1);\n        }\n      }\n\n      deadlineBackGradient.draw(batch, 0, BACK_GRADIENT_Y, BG_WIDTH, BACK_GRADIENT_Y);\n      deadlineBase.draw(batch, 0, BASE_Y, BG_WIDTH, BASE_HEIGHT);\n      for (let i = 0; i < PAPER_STACK_COUNT - 1; i++) {\n        paperStackAnimation\n          .getKeyFrame(stateTime + PAPER_STACK_ANIMATION_DELAY[i], PlayMode.LOOP_PINGPONG)\n          .draw(batch, PAPER_STACK_WIDTH * i + PAPER_STACK_WIDTH / 2, PAPER_STACK_Y - PAPER_STACK_HEIGHT / 8, PAPER_STACK_WIDTH, PAPER_STACK_HEIGHT);\n      }\n      for (let particle of deadlineParticles) {\n        (particle.type === 0 ? singlePaper : singleNote).draw(\n          batch,\n          particle.x,\n          particle.y,\n          particle.size,\n          particle.size,\n          particle.size / 2,\n          particle.size / 2,\n          particle.rotation\n        );\n      }\n      for (let i = 0; i < PAPER_STACK_COUNT; i++) {\n        paperStackAnimation\n          .getKeyFrame(stateTime + PAPER_STACK_ANIMATION_DELAY[i], PlayMode.LOOP_PINGPONG)\n          .draw(batch, PAPER_STACK_WIDTH * i, PAPER_STACK_Y, PAPER_STACK_WIDTH, PAPER_STACK_HEIGHT);\n      }\n      deadlineFrontGradient.draw(batch, 0, FRONT_GRADIENT_Y, BG_WIDTH, FRONT_GRADIENT_HEIGHT);\n    }\n  };\n};\n","const results = [];\n\nexport const calculateParallaxByOffset = (displaySize, texSize, offset) => {\n  results.length = 0;\n  let current = offset;\n  while (current > displaySize) {\n    current -= texSize;\n  }\n  while (current < -texSize) {\n    current += texSize;\n  }\n  const startPoint = current;\n  do {\n    results.push(current);\n    current += texSize;\n  } while (current < displaySize);\n  current = startPoint;\n  while (current > 0) {\n    current -= texSize;\n    results.push(current);\n  }\n  return results;\n};\n\nexport const calculateParallaxBySpeed = (\n  stateTime,\n  displaySize,\n  texSize,\n  speed\n) => {\n  const offset = speed * stateTime;\n  return calculateParallaxByOffset(displaySize, texSize, offset);\n};\n","import { calculateParallaxByOffset } from '../../util/parallaxCalculator';\n\nexport const createBgRenderSystem = (width, height, bg1, bg2, batch) => {\n  const BG_WIDTH = width;\n  const BG1_HEIGHT = (BG_WIDTH / bg1.width) * bg1.height;\n  const BG2_HEIGHT = (BG_WIDTH / bg2.width) * bg2.height;\n\n  return {\n    update(delta, y, gap) {\n      let drawStarts = calculateParallaxByOffset(height, BG2_HEIGHT, (-y + gap) * 0.5);\n      for (let drawStart of drawStarts) {\n        batch.draw(bg2, 0, drawStart, BG_WIDTH, BG2_HEIGHT);\n      }\n\n      drawStarts = calculateParallaxByOffset(height, BG1_HEIGHT, -y + gap);\n      for (let drawStart of drawStarts) {\n        batch.draw(bg1, 0, drawStart, BG_WIDTH, BG1_HEIGHT);\n      }\n    }\n  };\n};\n","export const createParticleSystem = (width, _height, noteTex, batch, PLAYER_SIZE) => {\n  const particles = [];\n  let particleTime = 0;\n  const PARTICLE_RATE = 0.075;\n  const PARTICLE_DURATION = 3;\n  const PARTICLE_SIZE = width / 30;\n  const PARTICLE_RANGE = width / 7.5;\n\n  return {\n    update(delta, x, y, speedY) {\n      particleTime += delta;\n      while (particleTime >= PARTICLE_RATE) {\n        particleTime -= PARTICLE_RATE;\n        particles.push({\n          x: x + PLAYER_SIZE / 2 + (Math.random() - 0.5) * PARTICLE_RANGE,\n          y: y + PLAYER_SIZE / 2 + (Math.random() - 0.5) * PARTICLE_RANGE,\n          speedY: speedY / 2,\n          type: Math.random() < 0.3 ? 0 : Math.random() < 0.5 ? 1 : 2,\n          rotation: (Math.random() * Math.PI) / 2,\n          duration: Math.random() * PARTICLE_DURATION,\n          t: 0,\n          size: PARTICLE_SIZE\n        });\n      }\n\n      for (let particle of particles) {\n        particle.t += delta;\n        particle.y += particle.speedY * delta;\n      }\n      for (let i = particles.length - 1; i >= 0; i--) {\n        const particle = particles[i];\n        if (particle.t >= particle.duration) {\n          particles.splice(i, 1);\n        }\n      }\n    },\n    draw() {\n      for (let particle of particles) {\n        let alpha = (particle.duration - particle.t) / particle.duration;\n        alpha = alpha * alpha * (3 - 2 * alpha);\n        batch.setColor(0, 0, 0, 0.75 * alpha);\n        batch.draw(\n          noteTex,\n          particle.x - particle.size / 2 + particle.size / 5,\n          particle.y - particle.size / 2 + particle.size / 5,\n          particle.size,\n          particle.size,\n          particle.size / 2,\n          particle.size / 2,\n          particle.rotation\n        );\n        particle.type === 0 && batch.setColor(1, 0.494, 0.725, alpha);\n        particle.type === 1 && batch.setColor(0.478, 0.988, 1, alpha);\n        particle.type === 2 && batch.setColor(1, 0.969, 0.251, alpha);\n        batch.draw(\n          noteTex,\n          particle.x - particle.size / 2,\n          particle.y - particle.size / 2,\n          particle.size,\n          particle.size,\n          particle.size / 2,\n          particle.size / 2,\n          particle.rotation\n        );\n        batch.setColor(1, 1, 1, 1);\n      }\n    }\n  };\n};\n","export const createWallSystem = (width, height, wallStarts, obstacles, WALL_LENGTH, WALL_THICKNESS, gap) => {\n  let latestWallStartGenerated = WALL_LENGTH;\n  const obstacleChance = 0.2;\n  const OBSTACLE_SIZE = width / 10;\n\n  return {\n    update(delta, y, gap) {\n      const screenY = y + gap;\n      for (let i = wallStarts.length - 1; i >= 0; i--) {\n        const wallStart = wallStarts[i];\n        if (wallStart - WALL_LENGTH > screenY) {\n          wallStarts.splice(i, 1);\n        }\n      }\n      for (let i = obstacles.length - 1; i >= 0; i--) {\n        const obstacle = obstacles[i];\n        if (obstacle.y > wallStarts[0]) {\n          obstacles.splice(i, 1);\n        }\n      }\n      while (latestWallStartGenerated > screenY - 2 * height - WALL_LENGTH) {\n        latestWallStartGenerated -= WALL_LENGTH;\n        wallStarts.push(latestWallStartGenerated);\n        if (latestWallStartGenerated > -height) {\n          continue;\n        }\n        if (Math.random() <= obstacleChance) {\n          const type = Math.floor(Math.random() * 4);\n          const wallIndex = Math.random() > 0.5 ? 0 : 1;\n          const obstacleWidth = type === 0 ? OBSTACLE_SIZE * 3 : OBSTACLE_SIZE * 2;\n          const obstacleHeight = type === 0 ? OBSTACLE_SIZE / 2 : OBSTACLE_SIZE * 2;\n          obstacles.push({\n            wallIndex,\n            y: type === 0 ? latestWallStartGenerated - WALL_LENGTH : latestWallStartGenerated - WALL_LENGTH - obstacleHeight * 0.9,\n            type,\n            width: obstacleWidth,\n            height: obstacleHeight,\n            x: wallIndex === 0 ? WALL_THICKNESS : width - WALL_THICKNESS - obstacleWidth\n          });\n        }\n      }\n    }\n  };\n};\n","import { fillRect } from 'gdxjs';\n\nexport const createWallRenderSystem = (width, height, whiteTex, batch, wallStarts, WALL_LENGTH, WALL_THICKNESS) => {\n  return {\n    draw() {\n      batch.setColor(0, 0, 0, 0.75);\n      for (let wallStart of wallStarts) {\n        fillRect(batch, whiteTex, 0, wallStart - WALL_LENGTH, WALL_THICKNESS, WALL_LENGTH);\n        fillRect(batch, whiteTex, width - WALL_THICKNESS, wallStart - WALL_LENGTH, WALL_THICKNESS, WALL_LENGTH);\n      }\n      batch.setColor(1, 1, 1, 1);\n    }\n  };\n};\n","import { createAnimation } from 'gdxjs';\nimport { PlayMode } from 'gdxjs/lib/createAnimation';\n\nexport const createPlayerRenderSystem = (width, height, batch, characterAtlas, slashAtlas, obstacleAtlas, watchAtlas, PLAYER_SIZE, gender, outfit) => {\n  let runAnimationName = `${gender === 0 ? 'man' : 'girl'}_running_${outfit + 1}`;\n  let jumpAnimationName = `${gender === 0 ? 'man' : 'girl'}_jump_${outfit + 1}`;\n  let runFrames = characterAtlas.findRegions(runAnimationName);\n  let jumpFrames = characterAtlas.findRegions(jumpAnimationName);\n  let runAnimation = createAnimation(0.05, runFrames);\n  let jumpAnimation = createAnimation(0.1, jumpFrames);\n\n  const updateOutfit = outfit => {\n    console.log('update outfit', outfit);\n    runAnimationName = `${gender === 0 ? 'man' : 'girl'}_running_${outfit + 1}`;\n    jumpAnimationName = `${gender === 0 ? 'man' : 'girl'}_jump_${outfit + 1}`;\n    runFrames = characterAtlas.findRegions(runAnimationName);\n    jumpFrames = characterAtlas.findRegions(jumpAnimationName);\n    runAnimation = createAnimation(0.05, runFrames);\n    jumpAnimation = createAnimation(0.1, jumpFrames);\n  };\n\n  const transitionAnimation = createAnimation(0.05, obstacleAtlas.findRegions('bullet_hit').slice(1, -1));\n  const slashFrames = slashAtlas.findRegions('slash');\n  const slashAnimation = createAnimation(0.03, slashFrames);\n  const buffAnimation = createAnimation(0.1, watchAtlas.findRegions('watch_buff'));\n\n  const SLASH_X = width * 0.1;\n  const SLASH_WIDTH = width * 0.8;\n  const SLASH_HEIGHT = (SLASH_WIDTH * slashFrames[0].height) / slashFrames[0].width;\n  let firstJump = true;\n\n  return {\n    draw(x, y, flipped, jumping, stateTime, jumpStart, buffTime, currentOutfit, transitionTime) {\n      if (outfit !== currentOutfit) {\n        outfit = currentOutfit;\n        updateOutfit(outfit);\n      }\n      const originX = PLAYER_SIZE / 2;\n      const originY = 0;\n      const scaleX = flipped ? 1 : -1;\n\n      if (transitionTime > stateTime - 0.1) {\n        batch.setColor(0.478, 0.988, 1, 1);\n        transitionAnimation.getKeyFrame(stateTime - transitionTime, PlayMode.LOOP_PINGPONG).draw(batch, x, y, PLAYER_SIZE * 2, PLAYER_SIZE);\n        batch.setColor(1, 1, 1, 1);\n        return;\n      }\n\n      if (!firstJump) {\n        slashAnimation\n          .getKeyFrame(stateTime - jumpStart, PlayMode.NORMAL)\n          .draw(batch, SLASH_X, y, SLASH_WIDTH, SLASH_HEIGHT, SLASH_WIDTH / 2, SLASH_HEIGHT / 2, 0, scaleX, 1.5);\n      }\n\n      if (!jumping) {\n        runAnimation.getKeyFrame(stateTime, PlayMode.LOOP_PINGPONG).draw(batch, x, y, PLAYER_SIZE, PLAYER_SIZE, originX, originY, 0, scaleX, 1);\n      } else {\n        firstJump = false;\n        jumpAnimation\n          .getKeyFrame(stateTime - jumpStart, PlayMode.NORMAL)\n          .draw(batch, x, y, (PLAYER_SIZE * 150) / 115, PLAYER_SIZE, originX, originY, 0, scaleX, 1);\n      }\n\n      if (buffTime >= stateTime) {\n        const frame = buffAnimation.getKeyFrame(stateTime - (buffTime - 2.5), PlayMode.LOOP_PINGPONG);\n        frame && frame.draw(batch, x, y, PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE / 2, PLAYER_SIZE / 2, 0, 1.5, 1.5);\n      }\n    }\n  };\n};\n","import { Vector2 } from 'gdxjs';\n\nexport const createObstacleSystem = (width, height, obstacles, WALL_LENGTH, WALL_THICKNESS, PROJECTILE_SPEED, PROJECTILE_SIZE) => {\n  const tmp = new Vector2();\n\n  return {\n    update(delta, y, stateTime) {\n      for (let obstacle of obstacles) {\n        if (obstacle.type > 0 && !obstacle.fired && Math.abs(obstacle.y - y) < WALL_LENGTH) {\n          obstacle.fired = true;\n          obstacle.projectilePos = new Vector2(obstacle.wallIndex === 0 ? WALL_THICKNESS : width - WALL_THICKNESS, obstacle.y);\n          const vel = new Vector2();\n          vel.set(obstacle.wallIndex === 0 ? PROJECTILE_SPEED : -PROJECTILE_SPEED, 0);\n          const rotation = -(Math.random() * Math.PI) / 6 - Math.PI / 18;\n          vel.rotateRad(obstacle.wallIndex === 0 ? rotation : -rotation);\n          obstacle.projectileVel = vel;\n          obstacle.projectileSize = PROJECTILE_SIZE;\n          obstacle.projectileStart = stateTime;\n        }\n        if (obstacle.fired) {\n          tmp.setVector(obstacle.projectileVel).scale(delta);\n          obstacle.projectilePos.addVector(tmp);\n        }\n      }\n    }\n  };\n};\n","import { fillRect, createAnimation } from 'gdxjs';\nimport { PlayMode } from 'gdxjs/lib/createAnimation';\n\nconst OBSTACLE_NAMES = [null, 'bed', 'bath', 'tivi'];\n\nexport const createObstacleRenderSystem = (whiteTex, batch, obstacles, obstacleAtlas) => {\n  const animations = [];\n  const idleAnimations = [];\n  const bulletAnimations = [];\n\n  const projectileHitAnimation = createAnimation(0.05, obstacleAtlas.findRegions('bullet_hit').slice(1, -1));\n  const coinAnimation = createAnimation(0.05, obstacleAtlas.findRegions('coin'));\n\n  for (let i = 0; i < OBSTACLE_NAMES.length; i++) {\n    if (i === 0) continue;\n    const frames = obstacleAtlas.findRegions(OBSTACLE_NAMES[i]);\n    animations[i] = createAnimation(0.1, frames);\n    idleAnimations[i] = createAnimation(0.1, frames.slice(0, 4));\n    bulletAnimations[i] = createAnimation(0.1, obstacleAtlas.findRegions(`${OBSTACLE_NAMES[i]}_bullet`));\n  }\n\n  return {\n    draw(stateTime) {\n      for (let obstacle of obstacles) {\n        const scaleX = obstacle.wallIndex === 0 ? -1 : 1;\n        if (obstacle.type === 0) {\n          batch.setColor(0, 0, 0, 0.75);\n          !obstacle.hit && fillRect(batch, whiteTex, obstacle.x, obstacle.y, obstacle.width, obstacle.height);\n          batch.setColor(1, 1, 1, 1);\n        } else {\n          if (obstacle.fired) {\n            !obstacle.hit &&\n              animations[obstacle.type]\n                .getKeyFrame(stateTime - obstacle.projectileStart, PlayMode.NORMAL)\n                .draw(batch, obstacle.x, obstacle.y, obstacle.width, obstacle.height, obstacle.width / 2, obstacle.height, 0, scaleX * 1.5, 1.5);\n            if (obstacle.projectileHit) {\n              if (stateTime - obstacle.projectileHitTime <= 11 * 0.05) {\n                batch.setColor(0, 0, 0, 0.25);\n                projectileHitAnimation\n                  .getKeyFrame(stateTime - obstacle.projectileHitTime, PlayMode.NORMAL)\n                  .draw(\n                    batch,\n                    obstacle.projectilePos.x - obstacle.projectileSize,\n                    obstacle.projectilePos.y,\n                    obstacle.projectileSize * 2,\n                    obstacle.projectileSize,\n                    obstacle.projectileSize,\n                    obstacle.projectileSize / 2,\n                    0,\n                    1.5,\n                    1.5\n                  );\n                batch.setColor(1, 1, 1, 1);\n                projectileHitAnimation\n                  .getKeyFrame(stateTime - obstacle.projectileHitTime, PlayMode.NORMAL)\n                  .draw(\n                    batch,\n                    obstacle.projectilePos.x - obstacle.projectileSize + obstacle.projectileSize * 0.05,\n                    obstacle.projectilePos.y + obstacle.projectileSize * 0.05,\n                    obstacle.projectileSize * 2,\n                    obstacle.projectileSize,\n                    obstacle.projectileSize,\n                    obstacle.projectileSize / 2,\n                    0,\n                    1.5,\n                    1.5\n                  );\n                coinAnimation\n                  .getKeyFrame(stateTime - obstacle.projectileHitTime, PlayMode.NORMAL)\n                  .draw(\n                    batch,\n                    obstacle.projectilePos.x,\n                    obstacle.projectilePos.y + obstacle.projectileSize / 2,\n                    obstacle.projectileSize,\n                    (obstacle.projectileSize / 8) * 10,\n                    obstacle.projectileSize / 2,\n                    0,\n                    0,\n                    2,\n                    2\n                  );\n              }\n            } else {\n              bulletAnimations[obstacle.type]\n                .getKeyFrame(stateTime, PlayMode.LOOP_PINGPONG)\n                .draw(\n                  batch,\n                  obstacle.projectilePos.x - obstacle.projectileSize / 2,\n                  obstacle.projectilePos.y - obstacle.projectileSize / 2,\n                  obstacle.projectileSize,\n                  obstacle.projectileSize,\n                  obstacle.projectileSize / 2,\n                  obstacle.projectileSize / 2,\n                  0,\n                  1.2,\n                  1.2\n                );\n            }\n          } else {\n            !obstacle.hit &&\n              idleAnimations[obstacle.type]\n                .getKeyFrame(stateTime, PlayMode.LOOP_PINGPONG)\n                .draw(batch, obstacle.x, obstacle.y, obstacle.width, obstacle.height, obstacle.width / 2, obstacle.height, 0, scaleX * 1.5, 1.5);\n          }\n        }\n      }\n    }\n  };\n};\n","import { createAnimation, fillRect } from 'gdxjs';\nimport { PlayMode } from 'gdxjs/lib/createAnimation';\n\nexport const createDebuffRenderSystem = (width, height, whiteTex, batch, debuffs, obstacleAtlas, gender, outfit) => {\n  const obstacleHitBaseName = `ob_${gender === 0 ? 'man' : 'girl'}`;\n\n  const OBSTACLE_HIT_TYPE_NAME = [null, `${obstacleHitBaseName}_2`, `${obstacleHitBaseName}_3`, `${obstacleHitBaseName}_1`];\n\n  const sampleFrame = obstacleAtlas.findRegion('ob_man_1');\n\n  const DEBUFF_WIDTH = width / 2;\n  const DEBUFF_HEIGHT = (DEBUFF_WIDTH * sampleFrame.height) / sampleFrame.width;\n\n  const obstacleHitAnimations = [];\n  for (let i = 0; i < OBSTACLE_HIT_TYPE_NAME.length; i++) {\n    if (i === 0) continue;\n    const regions = obstacleAtlas.findRegions(OBSTACLE_HIT_TYPE_NAME[i]);\n    obstacleHitAnimations[i] = createAnimation(0.05, regions);\n  }\n\n  return {\n    draw(stateTime, y) {\n      if (debuffs.length > 0) {\n        batch.setColor(0, 0, 0, 0.5);\n        fillRect(batch, whiteTex, 0, y - height, width, height * 2);\n        batch.setColor(1, 1, 1, 1);\n      }\n      for (let debuff of debuffs) {\n        if (debuff.type === 0) continue;\n        const animation = obstacleHitAnimations[debuff.type];\n        animation\n          .getKeyFrame(stateTime - debuff.time, PlayMode.NORMAL)\n          .draw(\n            batch,\n            debuff.x - DEBUFF_WIDTH / 2,\n            y + 2 * debuff.offsetY - DEBUFF_HEIGHT / 2,\n            DEBUFF_WIDTH,\n            DEBUFF_HEIGHT,\n            DEBUFF_WIDTH / 2,\n            DEBUFF_HEIGHT / 2,\n            0,\n            debuff.flipped ? 1 : -1,\n            1\n          );\n      }\n    }\n  };\n};\n","export const createWatchSystem = (width, height, watches) => {\n  const WATCH_SIZE = width / 5;\n  let timeUntilNextWatch = 5;\n  return {\n    update(delta, stateTime, y) {\n      timeUntilNextWatch -= delta;\n      if (timeUntilNextWatch <= 0) {\n        timeUntilNextWatch = Math.random() * 5 - 2.5 + 5;\n        watches.push({\n          x: width / 2,\n          y: y - height,\n          drawX: width / 2,\n          drawY: y - height,\n          drawScale: 1,\n          time: stateTime,\n          width: WATCH_SIZE,\n          height: WATCH_SIZE,\n          type: Math.floor(Math.random() * 3)\n        });\n      }\n      for (let i = watches.length - 1; i >= 0; i--) {\n        if (watches[i].y > y + 2 * height) {\n          watches.splice(i, 1);\n        }\n      }\n    }\n  };\n};\n","import { createAnimation } from 'gdxjs';\nimport { PlayMode } from 'gdxjs/lib/createAnimation';\n\nexport const createWatchRenderSystem = (width, height, batch, watchAtlas, watches, PLAYER_SIZE) => {\n  const watchAnimations = [];\n  for (let i = 0; i < 3; i++) {\n    watchAnimations.push(createAnimation(0.1, watchAtlas.findRegions(`watch_${i + 1}`)));\n  }\n  return {\n    draw(stateTime, x, y) {\n      for (let watch of watches) {\n        if (stateTime - watch.hitTime > 0.5) {\n          continue;\n        }\n        if (watch.hit) {\n          watch.drawX = watch.drawX + (x + PLAYER_SIZE / 2 - watch.drawX) * 0.2;\n          watch.drawY = watch.drawY + (y - watch.drawY) * 0.2;\n          watch.drawScale = watch.drawScale + (0.5 - watch.drawScale) * 0.2;\n        }\n        watchAnimations[watch.type]\n          .getKeyFrame(stateTime, PlayMode.LOOP)\n          .draw(\n            batch,\n            watch.drawX - watch.width / 2,\n            watch.drawY - watch.height / 2,\n            watch.width,\n            watch.height,\n            watch.width / 2,\n            watch.height / 2,\n            0,\n            watch.drawScale,\n            watch.drawScale\n          );\n      }\n    }\n  };\n};\n","import createScreen from '../util/createScreen';\nimport { InputHandler, createBatch, createOrthoCamera } from 'gdxjs';\nimport createWhiteTex from 'gl-white-texture';\nimport { createDeadlineRenderSystem } from './system/DeadlineRenderSystem';\nimport { createBgRenderSystem } from './system/BgRenderSystem';\nimport { createParticleSystem } from './system/ParticleSystem';\nimport { createWallSystem } from './system/WallSystem';\nimport { createWallRenderSystem } from './system/WallRenderSystem';\nimport { createPlayerRenderSystem } from './system/PlayerRenderSystem';\nimport { createObstacleSystem } from './system/ObstacleSystem';\nimport { createObstacleRenderSystem } from './system/ObstacleRenderSystem';\nimport { createDebuffRenderSystem } from './system/DebuffRenderSystem';\nimport { createWatchSystem } from './system/WatchSystem';\nimport { createWatchRenderSystem } from './system/WatchRenderSystem';\n\nexport const createTestScreen = async Game => {\n  const { gender = 0, gl, width, height, canvas, assets } = Game;\n  let outfit = 0;\n\n  const batch = createBatch(gl);\n  const camera = createOrthoCamera(width, height, width, height);\n  const whiteTex = createWhiteTex(gl);\n  const inputHandler = new InputHandler(canvas);\n  const { bg1, bg2, deadLineAtlas, characterAtlas, slashAtlas, obstacleAtlas, noteTex, watchAtlas } = assets;\n\n  const BG_WIDTH = width;\n  const BG1_HEIGHT = (BG_WIDTH / bg1.width) * bg1.height;\n\n  const WALL_THICKNESS = width * 0.05;\n  const WALL_LENGTH = BG1_HEIGHT / 7;\n  const JUMP_SPEED_X = width * 2;\n  const NORMAL_SPEED_Y = -height * 0.75;\n  const PLAYER_SIZE = width / 5;\n  let buffTime = 0;\n  let coinCount = 0;\n\n  const hasBuff = () => buffTime >= stateTime;\n\n  let x = WALL_THICKNESS;\n  let speedX = 0;\n  let y = 0;\n  let speedY = NORMAL_SPEED_Y;\n\n  const INITIAL_GAP = height * 0.6;\n\n  let targetGap = INITIAL_GAP;\n  let gap = INITIAL_GAP;\n\n  let flipped = false;\n  let jumping = false;\n\n  const wallStarts = [];\n  const debuffs = [];\n\n  const minX = WALL_THICKNESS;\n  const maxX = width - WALL_THICKNESS - PLAYER_SIZE;\n\n  let jumpStart = 0;\n\n  const jump = () => {\n    if (jumping || debuffs.length > 0) {\n      return;\n    }\n    speedX = flipped ? -JUMP_SPEED_X : JUMP_SPEED_X;\n    jumping = true;\n    jumpStart = stateTime;\n  };\n\n  inputHandler.addEventListener('touchStart', jump);\n  document.addEventListener('keydown', jump);\n\n  const checkLanding = newX => {\n    if (!jumping) {\n      return;\n    }\n    let landing = false;\n\n    if (newX > maxX) {\n      x = maxX;\n      landing = true;\n    }\n\n    if (newX < minX) {\n      x = minX;\n      landing = true;\n    }\n\n    if (landing) {\n      speedX = 0;\n      jumping = false;\n      flipped = !flipped;\n    }\n    return landing;\n  };\n\n  const processPlayerPos = delta => {\n    let modifier = 1;\n    if (debuffs.length > 0) {\n      modifier = 0.5;\n    }\n    if (hasBuff()) {\n      modifier *= 2;\n    }\n    y += speedY * delta * modifier;\n    const deltaX = speedX * delta;\n    if (!checkLanding(x + deltaX)) {\n      x += deltaX;\n    }\n  };\n\n  const processWatchCollsion = delta => {\n    const pL = x;\n    const pR = x + PLAYER_SIZE;\n    const pT = y;\n    const pB = y + PLAYER_SIZE;\n\n    for (let watch of watches) {\n      if (watch.hit) continue;\n\n      const oL = watch.x - watch.width / 2;\n      const oR = watch.x + watch.width / 2;\n      const oT = watch.y - watch.height / 2;\n      const oB = watch.y + watch.height / 2;\n      if (pL < oR && pR > oL && pT < oB && pB > oT) {\n        watch.hit = true;\n        watch.hitTime = stateTime;\n        buffTime = stateTime + 2.5;\n        gap = gap + (INITIAL_GAP - gap) * 0.5;\n      }\n    }\n  };\n\n  const processObstacleCollision = delta => {\n    const pL = x;\n    const pR = x + PLAYER_SIZE;\n    const pT = y;\n    const pB = y + PLAYER_SIZE;\n\n    let hitted = false;\n\n    for (let obstacle of obstacles) {\n      if (obstacle.hit) continue;\n      const oWidth = obstacle.width;\n      const oHeight = obstacle.height;\n      const oL = obstacle.x;\n      const oR = obstacle.x + oWidth;\n      const oT = obstacle.y;\n      const oB = obstacle.y + oHeight;\n\n      if (pL < oR && pR > oL && pT < oB && pB > oT && !jumping) {\n        obstacle.hit = true;\n        if (!hasBuff()) {\n          hitted = true;\n          debuffs.push({\n            time: stateTime,\n            duration: 1,\n            type: obstacle.type,\n            x: width / 2 + ((Math.random() - 0.5) * width) / 20,\n            offsetY: -((Math.random() * width) / 20 + width / 40),\n            flipped: flipped\n          });\n        }\n      }\n    }\n\n    for (let obstacle of obstacles) {\n      if (!obstacle.fired || obstacle.projectileHit) continue;\n      const pos = obstacle.projectilePos;\n      const size = obstacle.projectileSize;\n\n      const oL = pos.x - size / 3;\n      const oR = pos.x + size / 3;\n      const oT = pos.y - size / 3;\n      const oB = pos.y + size / 3;\n\n      if (pL < oR && pR > oL && pT < oB && pB > oT) {\n        obstacle.projectileHit = true;\n        obstacle.projectileHitTime = stateTime;\n        obstacle.projectileVel.set(0, speedY);\n        if (!jumping && !hasBuff()) {\n          debuffs.push({\n            time: stateTime,\n            duration: 1,\n            type: obstacle.type,\n            x: width / 2 + ((Math.random() - 0.5) * width) / 10,\n            offsetY: -((Math.random() * width) / 10 + width / 20),\n            flipped: flipped\n          });\n          obstacle.projectileVel.set(0, speedY / 2);\n          hitted = true;\n        } else {\n          targetGap = targetGap + (INITIAL_GAP - targetGap) * 0.2;\n          coinCount += 5;\n        }\n      }\n    }\n    if (hitted) {\n      targetGap = targetGap + (height - targetGap) * 0.2;\n      const rate = deadlineRenderSystem.getDeadLineParticleRate();\n      deadlineRenderSystem.setDeadLineParticleRate(rate + (MAXIMUM_DEADLINE_RATE - rate) * 0.2);\n    }\n  };\n\n  let transitionTime = -2;\n\n  const OUT_FIT_COIN_REQUIRED = [0, 50, 200];\n\n  const processOutfit = () => {\n    for (let i = 0; i < OUT_FIT_COIN_REQUIRED.length; i++) {\n      if (outfit >= i) {\n        continue;\n      }\n      if (coinCount > OUT_FIT_COIN_REQUIRED[i]) {\n        outfit = i;\n        transitionTime = stateTime;\n      }\n    }\n  };\n\n  const MAXIMUM_DEADLINE_RATE = 0.015;\n  const obstacles = [];\n  const watches = [];\n\n  const PROJECTILE_SPEED = width;\n  const PROJECTILE_SIZE = width / 7.5;\n\n  const deadlineRenderSystem = createDeadlineRenderSystem(width, height, deadLineAtlas, batch);\n  const bgRenderSystem = createBgRenderSystem(width, height, bg1, bg2, batch);\n  const particleSystem = createParticleSystem(width, height, noteTex, batch, PLAYER_SIZE);\n  const wallSystem = createWallSystem(width, height, wallStarts, obstacles, WALL_LENGTH, WALL_THICKNESS);\n  const wallRenderSystem = createWallRenderSystem(width, height, whiteTex, batch, wallStarts, WALL_LENGTH, WALL_THICKNESS);\n  const playerRenderSystem = createPlayerRenderSystem(width, height, batch, characterAtlas, slashAtlas, obstacleAtlas, watchAtlas, PLAYER_SIZE, gender, outfit);\n  const obstacleSystem = createObstacleSystem(width, height, obstacles, WALL_LENGTH, WALL_THICKNESS, PROJECTILE_SPEED, PROJECTILE_SIZE);\n  const obstacleRenderSystem = createObstacleRenderSystem(whiteTex, batch, obstacles, obstacleAtlas);\n  const debuffRenderSystem = createDebuffRenderSystem(width, height, whiteTex, batch, debuffs, obstacleAtlas, gender, outfit);\n  const watchSystem = createWatchSystem(width, height, watches);\n  const watchRenderSystem = createWatchRenderSystem(width, height, batch, watchAtlas, watches, PLAYER_SIZE);\n\n  let stateTime = 0;\n  const update = delta => {\n    if (hasBuff()) {\n      debuffs.length = 0;\n    }\n    gap = gap + (targetGap - gap) * 0.02;\n    for (let i = debuffs.length - 1; i >= 0; i--) {\n      if (stateTime - debuffs[i].time >= debuffs[i].duration) {\n        debuffs.splice(i, 1);\n      }\n    }\n    stateTime += delta;\n    particleSystem.update(delta, x, y, speedY);\n    processPlayerPos(delta);\n    processObstacleCollision(delta);\n    processWatchCollsion(delta);\n    processOutfit();\n    obstacleSystem.update(delta, y, stateTime);\n    wallSystem.update(delta, y, gap);\n    watchSystem.update(delta, stateTime, y);\n\n    camera.setPosition(0, 0);\n    batch.setProjection(camera.combined);\n    batch.begin();\n    bgRenderSystem.update(delta, y, gap);\n    deadlineRenderSystem.update(delta, stateTime);\n    batch.end();\n\n    camera.setPosition(0, y - gap);\n    batch.setProjection(camera.combined);\n    batch.begin();\n\n    particleSystem.draw();\n    playerRenderSystem.draw(x, y, flipped, jumping, stateTime, jumpStart, buffTime, outfit, transitionTime);\n    watchRenderSystem.draw(stateTime, x, y);\n    wallRenderSystem.draw();\n    obstacleRenderSystem.draw(stateTime);\n    debuffRenderSystem.draw(stateTime, y);\n\n    batch.end();\n  };\n\n  return createScreen({\n    update,\n    destroy() {\n      inputHandler.cleanup();\n      document.removeEventListener('keydown', jump);\n    }\n  });\n};\n","import './index.css';\n\nimport { resizeCanvas, createGameLoop, loadTexture, loadAtlas } from 'gdxjs';\nimport { createTestScreen } from './screen/testScreen';\n\nconst init = async () => {\n  const canvas = document.getElementById('main');\n  const loading = document.getElementById('loading');\n  const [width, height] = resizeCanvas(canvas, 1);\n  const gl = canvas.getContext('webgl');\n\n  const Game = {\n    width,\n    height,\n    canvas,\n    gl,\n    pixelRatio: 1,\n    setCurrentScreen(screen) {\n      if (Game.currentScreen) {\n        Game.currentScreen.destroy();\n      }\n      Game.currentScreen = screen;\n    }\n  };\n\n  let count = 0;\n  loading.innerHTML = `Loading (${count} / 7)...`;\n  const doAndCount = promise =>\n    promise.then(result => {\n      count++;\n      loading.innerHTML = `Loading (${count} / 8)...`;\n      return result;\n    });\n\n  const [bg1, bg2, deadLineAtlas, characterAtlas, slashAtlas, obstacleAtlas, noteTex, watchAtlas] = await Promise.all([\n    doAndCount(loadTexture(gl, './test-bg.png')),\n    doAndCount(loadTexture(gl, './test-bg2.jpg')),\n    doAndCount(loadAtlas(gl, './deadline.atlas')),\n    doAndCount(loadAtlas(gl, './test.atlas')),\n    doAndCount(loadAtlas(gl, './slash.atlas')),\n    doAndCount(loadAtlas(gl, './obstacle.atlas')),\n    doAndCount(loadTexture(gl, './note.png')),\n    doAndCount(loadAtlas(gl, './watch.atlas'))\n  ]);\n  const assets = { bg1, bg2, deadLineAtlas, characterAtlas, slashAtlas, obstacleAtlas, noteTex, watchAtlas };\n  Game.assets = assets;\n\n  Game.setCurrentScreen(await createTestScreen(Game));\n  loading.style.display = 'none';\n\n  gl.clearColor(1, 1, 1, 1);\n  const update = delta => {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    if (Game.currentScreen) {\n      Game.currentScreen.update(delta);\n    }\n  };\n\n  createGameLoop(update);\n};\n\ninit();\n"],"sourceRoot":""}