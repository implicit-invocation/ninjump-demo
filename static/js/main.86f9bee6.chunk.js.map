{"version":3,"sources":["util/createScreen.js","util/parallaxCalculator.js","screen/system/DeadlineRenderSystem.js","screen/system/BgRenderSystem.js","screen/system/ParticleSystem.js","screen/system/WallSystem.js","screen/system/WallRenderSystem.js","screen/system/PlayerRenderSystem.js","screen/system/ObstacleSystem.js","screen/system/ObstacleRenderSystem.js","screen/system/DebuffRenderSystem.js","screen/testScreen.js","index.js"],"names":["noop","createScreen","update","destroy","results","calculateParallaxByOffset","displaySize","texSize","offset","length","current","startPoint","push","createDeadlineRenderSystem","width","height","deadLineAtlas","batch","deadlineBackGradient","findRegion","deadlineFrontGradient","singleNote","singlePaper","deadlineBase","singlePaperStackFrame","paperStackAnimation","createAnimation","findRegions","PARTICLE_SIZE","BG_WIDTH","BACK_GRADIENT_HEIGHT","BACK_GRADIENT_Y","BASE_HEIGHT","BASE_Y","FRONT_GRADIENT_HEIGHT","FRONT_GRADIENT_Y","PAPER_STACK_WIDTH","PAPER_STACK_HEIGHT","PAPER_STACK_Y","PAPER_STACK_ANIMATION_DELAY","i","Math","random","deadlineParticleTime","deadLineParticleRate","deadlineParticles","DEADLINE_PARTICLE_SPEED","DEADLINE_PARTICLE_DECELERATOR","setDeadLineParticleRate","rate","getDeadLineParticleRate","delta","stateTime","type","x","y","size","speedY","rotation","PI","particle","expired","splice","draw","PAPER_STACK_COUNT","getKeyFrame","PlayMode","LOOP_PINGPONG","createBgRenderSystem","bg1","bg2","BG1_HEIGHT","BG2_HEIGHT","gap","drawStarts","drawStart","createParticleSystem","_height","noteTex","PLAYER_SIZE","particles","particleTime","PARTICLE_RANGE","duration","t","alpha","setColor","createWallSystem","wallStarts","obstacles","WALL_LENGTH","WALL_THICKNESS","latestWallStartGenerated","OBSTACLE_SIZE","screenY","floor","wallIndex","obstacleWidth","obstacleHeight","createWallRenderSystem","whiteTex","wallStart","fillRect","createPlayerRenderSystem","characterAtlas","slashAtlas","runAnimationName","jumpAnimationName","runFrames","jumpFrames","slashFrames","runAnimation","jumpAnimation","slashAnimation","SLASH_X","SLASH_WIDTH","SLASH_HEIGHT","firstJump","flipped","jumping","jumpStart","originX","scaleX","NORMAL","createObstacleSystem","PROJECTILE_SPEED","PROJECTILE_SIZE","tmp","Vector2","obstacle","fired","abs","projectilePos","vel","set","rotateRad","projectileVel","projectileSize","projectileStart","setVector","scale","addVector","OBSTACLE_NAMES","createObstacleRenderSystem","obstacleAtlas","animations","idleAnimations","bulletAnimations","projectileHitAnimation","slice","frames","hit","projectileHit","projectileHitTime","createDebuffRenderSystem","debuffs","gender","outfit","obstacleHitBaseName","OBSTACLE_HIT_TYPE_NAME","sampleFrame","DEBUFF_WIDTH","DEBUFF_HEIGHT","obstacleHitAnimations","regions","debuff","time","offsetY","createTestScreen","Game","a","gl","canvas","createBatch","camera","createOrthoCamera","createWhiteTex","inputHandler","InputHandler","loadTexture","loadAtlas","RUN_ANIMATION_NAME","JUMP_ANIMATION_NAME","JUMP_SPEED_X","speedX","targetGap","INITIAL_GAP","minX","maxX","jump","addEventListener","document","checkLanding","newX","landing","processPlayerPos","modifier","deltaX","processCollision","pL","pR","pT","pB","hitted","oWidth","oHeight","oL","oR","oT","oB","pos","deadlineRenderSystem","MAXIMUM_DEADLINE_RATE","bgRenderSystem","particleSystem","wallSystem","wallRenderSystem","playerRenderSystem","obstacleSystem","obstacleRenderSystem","debuffRenderSystem","setPosition","setProjection","combined","begin","end","cleanup","removeEventListener","getElementById","info","resizeCanvas","getContext","pixelRatio","setCurrentScreen","screen","currentScreen","clearColor","clear","COLOR_BUFFER_BIT","gameLoop","createGameLoop","setInterval","innerHTML","getFps","init"],"mappings":"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","file":"static/js/main.86f9bee6.chunk.js","sourcesContent":["const noop = () => {};\n\nconst createScreen = ({ update = noop, destroy = noop }) => {\n  return { update, destroy };\n};\n\nexport default createScreen;\n","const results = [];\n\nexport const calculateParallaxByOffset = (displaySize, texSize, offset) => {\n  results.length = 0;\n  let current = offset;\n  while (current > displaySize) {\n    current -= texSize;\n  }\n  while (current < -texSize) {\n    current += texSize;\n  }\n  const startPoint = current;\n  do {\n    results.push(current);\n    current += texSize;\n  } while (current < displaySize);\n  current = startPoint;\n  while (current > 0) {\n    current -= texSize;\n    results.push(current);\n  }\n  return results;\n};\n\nexport const calculateParallaxBySpeed = (\n  stateTime,\n  displaySize,\n  texSize,\n  speed\n) => {\n  const offset = speed * stateTime;\n  return calculateParallaxByOffset(displaySize, texSize, offset);\n};\n","import { createAnimation } from 'gdxjs';\nimport { PlayMode } from 'gdxjs/lib/createAnimation';\n\nexport const createDeadlineRenderSystem = (width, height, deadLineAtlas, batch) => {\n  const deadlineBackGradient = deadLineAtlas.findRegion('deadline-back-gradient');\n  const deadlineFrontGradient = deadLineAtlas.findRegion('deadline-front-gradient');\n  const singleNote = deadLineAtlas.findRegion('single-note');\n  const singlePaper = deadLineAtlas.findRegion('single-paper');\n  const deadlineBase = deadLineAtlas.findRegion('deadline-base');\n  const singlePaperStackFrame = deadLineAtlas.findRegion('paper_stack');\n  const paperStackAnimation = createAnimation(0.1, deadLineAtlas.findRegions('paper_stack'));\n\n  const PARTICLE_SIZE = width / 30;\n  const BG_WIDTH = width;\n  const BACK_GRADIENT_HEIGHT = (BG_WIDTH / deadlineBackGradient.width) * deadlineBackGradient.height;\n  const BACK_GRADIENT_Y = height - BACK_GRADIENT_HEIGHT;\n  const BASE_HEIGHT = (BG_WIDTH / deadlineBase.width) * deadlineBase.height;\n  const BASE_Y = height - BASE_HEIGHT / 2;\n  const FRONT_GRADIENT_HEIGHT = (BG_WIDTH / deadlineFrontGradient.width) * deadlineFrontGradient.height;\n  const FRONT_GRADIENT_Y = height - FRONT_GRADIENT_HEIGHT;\n\n  const PAPER_STACK_COUNT = 4;\n  const PAPER_STACK_WIDTH = width / PAPER_STACK_COUNT;\n  const PAPER_STACK_HEIGHT = (PAPER_STACK_WIDTH / singlePaperStackFrame.width) * singlePaperStackFrame.height;\n  const PAPER_STACK_Y = height - PAPER_STACK_HEIGHT;\n  const PAPER_STACK_ANIMATION_DELAY = [];\n  for (let i = 0; i < PAPER_STACK_COUNT; i++) {\n    PAPER_STACK_ANIMATION_DELAY[i] = Math.random() * 0.5;\n  }\n\n  let deadlineParticleTime = 0;\n  let deadLineParticleRate = 0.15;\n  const deadlineParticles = [];\n  const DEADLINE_PARTICLE_SPEED = -height / 2;\n  const DEADLINE_PARTICLE_DECELERATOR = height * 0.75;\n\n  return {\n    setDeadLineParticleRate(rate) {\n      deadLineParticleRate = rate;\n    },\n    getDeadLineParticleRate() {\n      return deadLineParticleRate;\n    },\n    update(delta, stateTime) {\n      deadlineParticleTime += delta;\n      while (deadlineParticleTime >= deadLineParticleRate) {\n        deadlineParticleTime -= deadLineParticleRate;\n        const type = Math.random() > 0.5 ? 0 : 1;\n        deadlineParticles.push({\n          x: Math.random() * width,\n          y: height,\n          size: type === 0 ? PARTICLE_SIZE * 2 : PARTICLE_SIZE,\n          speedY: DEADLINE_PARTICLE_SPEED,\n          type,\n          rotation: (Math.random() * Math.PI) / 2\n        });\n      }\n\n      for (let particle of deadlineParticles) {\n        particle.speedY += DEADLINE_PARTICLE_DECELERATOR * delta;\n        particle.y = particle.y + particle.speedY * delta;\n        if (particle.y > height) {\n          particle.expired = true;\n        }\n      }\n\n      for (let i = deadlineParticles.length - 1; i >= 0; i--) {\n        if (deadlineParticles[i].expired) {\n          deadlineParticles.splice(i, 1);\n        }\n      }\n\n      deadlineBackGradient.draw(batch, 0, BACK_GRADIENT_Y, BG_WIDTH, BACK_GRADIENT_Y);\n      deadlineBase.draw(batch, 0, BASE_Y, BG_WIDTH, BASE_HEIGHT);\n      for (let i = 0; i < PAPER_STACK_COUNT - 1; i++) {\n        paperStackAnimation\n          .getKeyFrame(stateTime + PAPER_STACK_ANIMATION_DELAY[i], PlayMode.LOOP_PINGPONG)\n          .draw(batch, PAPER_STACK_WIDTH * i + PAPER_STACK_WIDTH / 2, PAPER_STACK_Y - PAPER_STACK_HEIGHT / 8, PAPER_STACK_WIDTH, PAPER_STACK_HEIGHT);\n      }\n      for (let particle of deadlineParticles) {\n        (particle.type === 0 ? singlePaper : singleNote).draw(\n          batch,\n          particle.x,\n          particle.y,\n          particle.size,\n          particle.size,\n          particle.size / 2,\n          particle.size / 2,\n          particle.rotation\n        );\n      }\n      for (let i = 0; i < PAPER_STACK_COUNT; i++) {\n        paperStackAnimation\n          .getKeyFrame(stateTime + PAPER_STACK_ANIMATION_DELAY[i], PlayMode.LOOP_PINGPONG)\n          .draw(batch, PAPER_STACK_WIDTH * i, PAPER_STACK_Y, PAPER_STACK_WIDTH, PAPER_STACK_HEIGHT);\n      }\n      deadlineFrontGradient.draw(batch, 0, FRONT_GRADIENT_Y, BG_WIDTH, FRONT_GRADIENT_HEIGHT);\n    }\n  };\n};\n","import { calculateParallaxByOffset } from '../../util/parallaxCalculator';\n\nexport const createBgRenderSystem = (width, height, bg1, bg2, batch) => {\n  const BG_WIDTH = width;\n  const BG1_HEIGHT = (BG_WIDTH / bg1.width) * bg1.height;\n  const BG2_HEIGHT = (BG_WIDTH / bg2.width) * bg2.height;\n\n  return {\n    update(delta, y, gap) {\n      let drawStarts = calculateParallaxByOffset(height, BG2_HEIGHT, (-y + gap) * 0.5);\n      for (let drawStart of drawStarts) {\n        batch.draw(bg2, 0, drawStart, BG_WIDTH, BG2_HEIGHT);\n      }\n\n      drawStarts = calculateParallaxByOffset(height, BG1_HEIGHT, -y + gap);\n      for (let drawStart of drawStarts) {\n        batch.draw(bg1, 0, drawStart, BG_WIDTH, BG1_HEIGHT);\n      }\n    }\n  };\n};\n","export const createParticleSystem = (width, _height, noteTex, batch, PLAYER_SIZE) => {\n  const particles = [];\n  let particleTime = 0;\n  const PARTICLE_RATE = 0.075;\n  const PARTICLE_DURATION = 3;\n  const PARTICLE_SIZE = width / 30;\n  const PARTICLE_RANGE = width / 7.5;\n\n  return {\n    update(delta, x, y, speedY) {\n      particleTime += delta;\n      while (particleTime >= PARTICLE_RATE) {\n        particleTime -= PARTICLE_RATE;\n        particles.push({\n          x: x + PLAYER_SIZE / 2 + (Math.random() - 0.5) * PARTICLE_RANGE,\n          y: y + PLAYER_SIZE / 2 + (Math.random() - 0.5) * PARTICLE_RANGE,\n          speedY: speedY / 2,\n          type: Math.random() < 0.3 ? 0 : Math.random() < 0.5 ? 1 : 2,\n          rotation: (Math.random() * Math.PI) / 2,\n          duration: Math.random() * PARTICLE_DURATION,\n          t: 0,\n          size: PARTICLE_SIZE\n        });\n      }\n\n      for (let particle of particles) {\n        particle.t += delta;\n        particle.y += particle.speedY * delta;\n      }\n      for (let i = particles.length - 1; i >= 0; i--) {\n        const particle = particles[i];\n        if (particle.t >= particle.duration) {\n          particles.splice(i, 1);\n        }\n      }\n    },\n    draw() {\n      for (let particle of particles) {\n        let alpha = (particle.duration - particle.t) / particle.duration;\n        alpha = alpha * alpha * (3 - 2 * alpha);\n        batch.setColor(0, 0, 0, 0.75 * alpha);\n        batch.draw(\n          noteTex,\n          particle.x - particle.size / 2 + particle.size / 5,\n          particle.y - particle.size / 2 + particle.size / 5,\n          particle.size,\n          particle.size,\n          particle.size / 2,\n          particle.size / 2,\n          particle.rotation\n        );\n        particle.type === 0 && batch.setColor(1, 0.494, 0.725, alpha);\n        particle.type === 1 && batch.setColor(0.478, 0.988, 1, alpha);\n        particle.type === 2 && batch.setColor(1, 0.969, 0.251, alpha);\n        batch.draw(\n          noteTex,\n          particle.x - particle.size / 2,\n          particle.y - particle.size / 2,\n          particle.size,\n          particle.size,\n          particle.size / 2,\n          particle.size / 2,\n          particle.rotation\n        );\n        batch.setColor(1, 1, 1, 1);\n      }\n    }\n  };\n};\n","export const createWallSystem = (width, height, wallStarts, obstacles, WALL_LENGTH, WALL_THICKNESS, gap) => {\n  let latestWallStartGenerated = WALL_LENGTH;\n  const obstacleChance = 0.2;\n  const OBSTACLE_SIZE = width / 10;\n\n  return {\n    update(delta, y, gap) {\n      const screenY = y + gap;\n      for (let i = wallStarts.length - 1; i >= 0; i--) {\n        const wallStart = wallStarts[i];\n        if (wallStart - WALL_LENGTH > screenY) {\n          wallStarts.splice(i, 1);\n        }\n      }\n      for (let i = obstacles.length - 1; i >= 0; i--) {\n        const obstacle = obstacles[i];\n        if (obstacle.y > wallStarts[0]) {\n          obstacles.splice(i, 1);\n        }\n      }\n      while (latestWallStartGenerated > screenY - 2 * height - WALL_LENGTH) {\n        latestWallStartGenerated -= WALL_LENGTH;\n        wallStarts.push(latestWallStartGenerated);\n        if (latestWallStartGenerated > -height) {\n          continue;\n        }\n        if (Math.random() <= obstacleChance) {\n          const type = Math.floor(Math.random() * 4);\n          const wallIndex = Math.random() > 0.5 ? 0 : 1;\n          const obstacleWidth = type === 0 ? OBSTACLE_SIZE * 3 : OBSTACLE_SIZE * 2;\n          const obstacleHeight = type === 0 ? OBSTACLE_SIZE / 2 : OBSTACLE_SIZE * 2;\n          obstacles.push({\n            wallIndex,\n            y: type === 0 ? latestWallStartGenerated - WALL_LENGTH : latestWallStartGenerated - WALL_LENGTH - obstacleHeight * 0.9,\n            type,\n            width: obstacleWidth,\n            height: obstacleHeight,\n            x: wallIndex === 0 ? WALL_THICKNESS : width - WALL_THICKNESS - obstacleWidth\n          });\n        }\n      }\n    }\n  };\n};\n","import { fillRect } from 'gdxjs';\n\nexport const createWallRenderSystem = (width, height, whiteTex, batch, wallStarts, WALL_LENGTH, WALL_THICKNESS) => {\n  return {\n    draw() {\n      batch.setColor(0, 0, 0, 0.75);\n      for (let wallStart of wallStarts) {\n        fillRect(batch, whiteTex, 0, wallStart - WALL_LENGTH, WALL_THICKNESS, WALL_LENGTH);\n        fillRect(batch, whiteTex, width - WALL_THICKNESS, wallStart - WALL_LENGTH, WALL_THICKNESS, WALL_LENGTH);\n      }\n      batch.setColor(1, 1, 1, 1);\n    }\n  };\n};\n","import { createAnimation } from 'gdxjs';\nimport { PlayMode } from 'gdxjs/lib/createAnimation';\n\nexport const createPlayerRenderSystem = (width, height, batch, characterAtlas, slashAtlas, runAnimationName, jumpAnimationName, PLAYER_SIZE) => {\n  const runFrames = characterAtlas.findRegions(runAnimationName);\n  const jumpFrames = characterAtlas.findRegions(jumpAnimationName);\n  const slashFrames = slashAtlas.findRegions('slash');\n\n  const runAnimation = createAnimation(0.05, runFrames);\n  const jumpAnimation = createAnimation(0.1, jumpFrames);\n  const slashAnimation = createAnimation(0.03, slashFrames);\n\n  const SLASH_X = width * 0.1;\n  const SLASH_WIDTH = width * 0.8;\n  const SLASH_HEIGHT = (SLASH_WIDTH * slashFrames[0].height) / slashFrames[0].width;\n  let firstJump = true;\n\n  return {\n    draw(x, y, flipped, jumping, stateTime, jumpStart) {\n      const originX = PLAYER_SIZE / 2;\n      const originY = 0;\n      const scaleX = flipped ? 1 : -1;\n\n      if (!firstJump) {\n        slashAnimation\n          .getKeyFrame(stateTime - jumpStart, PlayMode.NORMAL)\n          .draw(batch, SLASH_X, y, SLASH_WIDTH, SLASH_HEIGHT, SLASH_WIDTH / 2, SLASH_HEIGHT / 2, 0, scaleX, 1.5);\n      }\n\n      if (!jumping) {\n        runAnimation.getKeyFrame(stateTime, PlayMode.LOOP_PINGPONG).draw(batch, x, y, PLAYER_SIZE, PLAYER_SIZE, originX, originY, 0, scaleX, 1);\n      } else {\n        firstJump = false;\n        jumpAnimation\n          .getKeyFrame(stateTime - jumpStart, PlayMode.NORMAL)\n          .draw(batch, x, y, (PLAYER_SIZE * 150) / 115, PLAYER_SIZE, originX, originY, 0, scaleX, 1);\n      }\n    }\n  };\n};\n","import { Vector2 } from 'gdxjs';\n\nexport const createObstacleSystem = (width, height, obstacles, WALL_LENGTH, WALL_THICKNESS, PROJECTILE_SPEED, PROJECTILE_SIZE) => {\n  const tmp = new Vector2();\n\n  return {\n    update(delta, y, stateTime) {\n      for (let obstacle of obstacles) {\n        if (obstacle.type > 0 && !obstacle.fired && Math.abs(obstacle.y - y) < WALL_LENGTH) {\n          obstacle.fired = true;\n          obstacle.projectilePos = new Vector2(obstacle.wallIndex === 0 ? WALL_THICKNESS : width - WALL_THICKNESS, obstacle.y);\n          const vel = new Vector2();\n          vel.set(obstacle.wallIndex === 0 ? PROJECTILE_SPEED : -PROJECTILE_SPEED, 0);\n          const rotation = -(Math.random() * Math.PI) / 6 - Math.PI / 18;\n          vel.rotateRad(obstacle.wallIndex === 0 ? rotation : -rotation);\n          obstacle.projectileVel = vel;\n          obstacle.projectileSize = PROJECTILE_SIZE;\n          obstacle.projectileStart = stateTime;\n        }\n        if (obstacle.fired) {\n          tmp.setVector(obstacle.projectileVel).scale(delta);\n          obstacle.projectilePos.addVector(tmp);\n        }\n      }\n    }\n  };\n};\n","import { fillRect, createAnimation } from 'gdxjs';\nimport { PlayMode } from 'gdxjs/lib/createAnimation';\n\nconst OBSTACLE_NAMES = [null, 'bed', 'bath', 'tivi'];\n\nexport const createObstacleRenderSystem = (whiteTex, batch, obstacles, obstacleAtlas) => {\n  const animations = [];\n  const idleAnimations = [];\n  const bulletAnimations = [];\n\n  const projectileHitAnimation = createAnimation(0.05, obstacleAtlas.findRegions('bullet_hit').slice(1, -1));\n\n  for (let i = 0; i < OBSTACLE_NAMES.length; i++) {\n    if (i === 0) continue;\n    const frames = obstacleAtlas.findRegions(OBSTACLE_NAMES[i]);\n    animations[i] = createAnimation(0.1, frames);\n    idleAnimations[i] = createAnimation(0.1, frames.slice(0, 4));\n    bulletAnimations[i] = createAnimation(0.1, obstacleAtlas.findRegions(`${OBSTACLE_NAMES[i]}_bullet`));\n  }\n\n  return {\n    draw(stateTime) {\n      for (let obstacle of obstacles) {\n        const scaleX = obstacle.wallIndex === 0 ? -1 : 1;\n        if (obstacle.type === 0) {\n          batch.setColor(0, 0, 0, 0.75);\n          !obstacle.hit && fillRect(batch, whiteTex, obstacle.x, obstacle.y, obstacle.width, obstacle.height);\n          batch.setColor(1, 1, 1, 1);\n        } else {\n          if (obstacle.fired) {\n            !obstacle.hit &&\n              animations[obstacle.type]\n                .getKeyFrame(stateTime - obstacle.projectileStart, PlayMode.NORMAL)\n                .draw(batch, obstacle.x, obstacle.y, obstacle.width, obstacle.height, obstacle.width / 2, obstacle.height, 0, scaleX * 1.5, 1.5);\n            if (obstacle.projectileHit) {\n              if (stateTime - obstacle.projectileHitTime <= 11 * 0.05) {\n                batch.setColor(0, 0, 0, 0.25);\n                projectileHitAnimation\n                  .getKeyFrame(stateTime - obstacle.projectileHitTime, PlayMode.NORMAL)\n                  .draw(\n                    batch,\n                    obstacle.projectilePos.x - obstacle.projectileSize,\n                    obstacle.projectilePos.y,\n                    obstacle.projectileSize * 2,\n                    obstacle.projectileSize,\n                    obstacle.projectileSize,\n                    obstacle.projectileSize / 2,\n                    0,\n                    1.5,\n                    1.5\n                  );\n                batch.setColor(1, 1, 1, 1);\n                projectileHitAnimation\n                  .getKeyFrame(stateTime - obstacle.projectileHitTime, PlayMode.NORMAL)\n                  .draw(\n                    batch,\n                    obstacle.projectilePos.x - obstacle.projectileSize + obstacle.projectileSize * 0.05,\n                    obstacle.projectilePos.y + obstacle.projectileSize * 0.05,\n                    obstacle.projectileSize * 2,\n                    obstacle.projectileSize,\n                    obstacle.projectileSize,\n                    obstacle.projectileSize / 2,\n                    0,\n                    1.5,\n                    1.5\n                  );\n              }\n            } else {\n              bulletAnimations[obstacle.type]\n                .getKeyFrame(stateTime, PlayMode.LOOP_PINGPONG)\n                .draw(\n                  batch,\n                  obstacle.projectilePos.x - obstacle.projectileSize / 2,\n                  obstacle.projectilePos.y - obstacle.projectileSize / 2,\n                  obstacle.projectileSize,\n                  obstacle.projectileSize,\n                  obstacle.projectileSize / 2,\n                  obstacle.projectileSize / 2,\n                  0,\n                  1.2,\n                  1.2\n                );\n            }\n          } else {\n            !obstacle.hit &&\n              idleAnimations[obstacle.type]\n                .getKeyFrame(stateTime, PlayMode.LOOP_PINGPONG)\n                .draw(batch, obstacle.x, obstacle.y, obstacle.width, obstacle.height, obstacle.width / 2, obstacle.height, 0, scaleX * 1.5, 1.5);\n          }\n        }\n      }\n    }\n  };\n};\n","import { createAnimation, fillRect } from 'gdxjs';\nimport { PlayMode } from 'gdxjs/lib/createAnimation';\n\nexport const createDebuffRenderSystem = (width, height, whiteTex, batch, debuffs, obstacleAtlas, gender, outfit) => {\n  const obstacleHitBaseName = `ob_${gender === 0 ? 'man' : 'girl'}`;\n\n  const OBSTACLE_HIT_TYPE_NAME = [null, `${obstacleHitBaseName}_2`, `${obstacleHitBaseName}_3`, `${obstacleHitBaseName}_1`];\n\n  const sampleFrame = obstacleAtlas.findRegion('ob_man_1');\n\n  const DEBUFF_WIDTH = width / 2;\n  const DEBUFF_HEIGHT = (DEBUFF_WIDTH * sampleFrame.height) / sampleFrame.width;\n\n  const obstacleHitAnimations = [];\n  for (let i = 0; i < OBSTACLE_HIT_TYPE_NAME.length; i++) {\n    if (i === 0) continue;\n    const regions = obstacleAtlas.findRegions(OBSTACLE_HIT_TYPE_NAME[i]);\n    obstacleHitAnimations[i] = createAnimation(0.05, regions);\n  }\n\n  return {\n    draw(stateTime, y) {\n      if (debuffs.length > 0) {\n        batch.setColor(0, 0, 0, 0.5);\n        fillRect(batch, whiteTex, 0, y - height, width, height * 2);\n        batch.setColor(1, 1, 1, 1);\n      }\n      for (let debuff of debuffs) {\n        if (debuff.type === 0) continue;\n        const animation = obstacleHitAnimations[debuff.type];\n        animation\n          .getKeyFrame(stateTime - debuff.time, PlayMode.NORMAL)\n          .draw(\n            batch,\n            debuff.x - DEBUFF_WIDTH / 2,\n            y + 2 * debuff.offsetY - DEBUFF_HEIGHT / 2,\n            DEBUFF_WIDTH,\n            DEBUFF_HEIGHT,\n            DEBUFF_WIDTH / 2,\n            DEBUFF_HEIGHT / 2,\n            0,\n            debuff.flipped ? 1 : -1,\n            1\n          );\n      }\n    }\n  };\n};\n","import createScreen from '../util/createScreen';\nimport { InputHandler, createBatch, createOrthoCamera, loadTexture, loadAtlas } from 'gdxjs';\nimport createWhiteTex from 'gl-white-texture';\nimport { createDeadlineRenderSystem } from './system/DeadlineRenderSystem';\nimport { createBgRenderSystem } from './system/BgRenderSystem';\nimport { createParticleSystem } from './system/ParticleSystem';\nimport { createWallSystem } from './system/WallSystem';\nimport { createWallRenderSystem } from './system/WallRenderSystem';\nimport { createPlayerRenderSystem } from './system/PlayerRenderSystem';\nimport { createObstacleSystem } from './system/ObstacleSystem';\nimport { createObstacleRenderSystem } from './system/ObstacleRenderSystem';\nimport { createDebuffRenderSystem } from './system/DebuffRenderSystem';\n\nexport const createTestScreen = async Game => {\n  const { gender = 0, outfit = 0, gl, width, height, canvas } = Game;\n\n  const batch = createBatch(gl);\n  const camera = createOrthoCamera(width, height, width, height);\n  const whiteTex = createWhiteTex(gl);\n  const inputHandler = new InputHandler(canvas);\n\n  const bg1 = await loadTexture(gl, './test-bg.png');\n  const bg2 = await loadTexture(gl, './test-bg2.jpg');\n  const deadLineAtlas = await loadAtlas(gl, './deadline.atlas');\n  const characterAtlas = await loadAtlas(gl, './test.atlas');\n  const slashAtlas = await loadAtlas(gl, './slash.atlas');\n  const obstacleAtlas = await loadAtlas(gl, './obstacle.atlas');\n\n  const noteTex = await loadTexture(gl, './note.png');\n\n  const RUN_ANIMATION_NAME = `${gender === 0 ? 'man' : 'girl'}_running_${outfit + 1}`;\n  const JUMP_ANIMATION_NAME = `${gender === 0 ? 'man' : 'girl'}_jump_${outfit + 1}`;\n\n  const BG_WIDTH = width;\n  const BG1_HEIGHT = (BG_WIDTH / bg1.width) * bg1.height;\n\n  const WALL_THICKNESS = width * 0.05;\n  const WALL_LENGTH = BG1_HEIGHT / 7;\n  const JUMP_SPEED_X = width * 2;\n  const NORMAL_SPEED_Y = -height * 0.75;\n  const PLAYER_SIZE = width / 5;\n\n  let x = WALL_THICKNESS;\n  let speedX = 0;\n  let y = 0;\n  let speedY = NORMAL_SPEED_Y;\n\n  const INITIAL_GAP = height * 0.6;\n\n  let targetGap = INITIAL_GAP;\n  let gap = INITIAL_GAP;\n\n  let flipped = false;\n  let jumping = false;\n\n  const wallStarts = [];\n  const debuffs = [];\n\n  const minX = WALL_THICKNESS;\n  const maxX = width - WALL_THICKNESS - PLAYER_SIZE;\n\n  let jumpStart = 0;\n\n  const jump = () => {\n    if (jumping || debuffs.length > 0) {\n      return;\n    }\n    speedX = flipped ? -JUMP_SPEED_X : JUMP_SPEED_X;\n    jumping = true;\n    jumpStart = stateTime;\n  };\n\n  inputHandler.addEventListener('touchStart', jump);\n  document.addEventListener('keydown', jump);\n\n  const checkLanding = newX => {\n    if (!jumping) {\n      return;\n    }\n    let landing = false;\n\n    if (newX > maxX) {\n      x = maxX;\n      landing = true;\n    }\n\n    if (newX < minX) {\n      x = minX;\n      landing = true;\n    }\n\n    if (landing) {\n      speedX = 0;\n      jumping = false;\n      flipped = !flipped;\n    }\n    return landing;\n  };\n\n  const processPlayerPos = delta => {\n    let modifier = 1;\n    if (debuffs.length > 0) {\n      modifier = 0.5;\n    }\n    y += speedY * delta * modifier;\n    const deltaX = speedX * delta;\n    if (!checkLanding(x + deltaX)) {\n      x += deltaX;\n    }\n  };\n\n  const processCollision = delta => {\n    const pL = x;\n    const pR = x + PLAYER_SIZE;\n    const pT = y;\n    const pB = y + PLAYER_SIZE;\n\n    let hitted = false;\n\n    for (let obstacle of obstacles) {\n      if (obstacle.hit) continue;\n      const oWidth = obstacle.width;\n      const oHeight = obstacle.height;\n      const oL = obstacle.x;\n      const oR = obstacle.x + oWidth;\n      const oT = obstacle.y;\n      const oB = obstacle.y + oHeight;\n\n      if (pL < oR && pR > oL && pT < oB && pB > oT && !jumping) {\n        hitted = true;\n        obstacle.hit = true;\n        debuffs.push({\n          time: stateTime,\n          duration: 1,\n          type: obstacle.type,\n          x: width / 2 + ((Math.random() - 0.5) * width) / 20,\n          offsetY: -((Math.random() * width) / 20 + width / 40),\n          flipped: flipped\n        });\n      }\n    }\n\n    for (let obstacle of obstacles) {\n      if (!obstacle.fired || obstacle.projectileHit) continue;\n      const pos = obstacle.projectilePos;\n      const size = obstacle.projectileSize;\n\n      const oL = pos.x - size / 3;\n      const oR = pos.x + size / 3;\n      const oT = pos.y - size / 3;\n      const oB = pos.y + size / 3;\n\n      if (pL < oR && pR > oL && pT < oB && pB > oT) {\n        obstacle.projectileHit = true;\n        obstacle.projectileHitTime = stateTime;\n        obstacle.projectileVel.set(0, speedY);\n        if (!jumping) {\n          debuffs.push({\n            time: stateTime,\n            duration: 1,\n            type: obstacle.type,\n            x: width / 2 + ((Math.random() - 0.5) * width) / 10,\n            offsetY: -((Math.random() * width) / 10 + width / 20),\n            flipped: flipped\n          });\n          obstacle.projectileVel.set(0, speedY / 2);\n          hitted = true;\n        } else {\n          targetGap = targetGap + (INITIAL_GAP - targetGap) * 0.2;\n        }\n      }\n    }\n    if (hitted) {\n      targetGap = targetGap + (height - targetGap) * 0.2;\n      const rate = deadlineRenderSystem.getDeadLineParticleRate();\n      deadlineRenderSystem.setDeadLineParticleRate(rate + (MAXIMUM_DEADLINE_RATE - rate) * 0.2);\n    }\n  };\n\n  const MAXIMUM_DEADLINE_RATE = 0.015;\n  const obstacles = [];\n\n  const PROJECTILE_SPEED = width;\n  const PROJECTILE_SIZE = width / 7.5;\n\n  const deadlineRenderSystem = createDeadlineRenderSystem(width, height, deadLineAtlas, batch);\n  const bgRenderSystem = createBgRenderSystem(width, height, bg1, bg2, batch);\n  const particleSystem = createParticleSystem(width, height, noteTex, batch, PLAYER_SIZE);\n  const wallSystem = createWallSystem(width, height, wallStarts, obstacles, WALL_LENGTH, WALL_THICKNESS);\n  const wallRenderSystem = createWallRenderSystem(width, height, whiteTex, batch, wallStarts, WALL_LENGTH, WALL_THICKNESS);\n  const playerRenderSystem = createPlayerRenderSystem(width, height, batch, characterAtlas, slashAtlas, RUN_ANIMATION_NAME, JUMP_ANIMATION_NAME, PLAYER_SIZE);\n  const obstacleSystem = createObstacleSystem(width, height, obstacles, WALL_LENGTH, WALL_THICKNESS, PROJECTILE_SPEED, PROJECTILE_SIZE);\n  const obstacleRenderSystem = createObstacleRenderSystem(whiteTex, batch, obstacles, obstacleAtlas);\n  const debuffRenderSystem = createDebuffRenderSystem(width, height, whiteTex, batch, debuffs, obstacleAtlas, gender, outfit);\n\n  let stateTime = 0;\n  const update = delta => {\n    gap = gap + (targetGap - gap) * 0.02;\n    for (let i = debuffs.length - 1; i >= 0; i--) {\n      if (stateTime - debuffs[i].time >= debuffs[i].duration) {\n        debuffs.splice(i, 1);\n      }\n    }\n    stateTime += delta;\n    particleSystem.update(delta, x, y, speedY);\n    processPlayerPos(delta);\n    processCollision(delta);\n    obstacleSystem.update(delta, y, stateTime);\n    wallSystem.update(delta, y, gap);\n\n    camera.setPosition(0, 0);\n    batch.setProjection(camera.combined);\n    batch.begin();\n    bgRenderSystem.update(delta, y, gap);\n    deadlineRenderSystem.update(delta, stateTime);\n    batch.end();\n\n    camera.setPosition(0, y - gap);\n    batch.setProjection(camera.combined);\n    batch.begin();\n\n    particleSystem.draw();\n    playerRenderSystem.draw(x, y, flipped, jumping, stateTime, jumpStart);\n    wallRenderSystem.draw();\n    obstacleRenderSystem.draw(stateTime);\n    debuffRenderSystem.draw(stateTime, y);\n\n    batch.end();\n  };\n\n  return createScreen({\n    update,\n    destroy() {\n      inputHandler.cleanup();\n      document.removeEventListener('keydown', jump);\n    }\n  });\n};\n","import './index.css';\n\nimport { resizeCanvas, createGameLoop } from 'gdxjs';\n// eslint-disable-next-line\nimport { createGenderChoosingScreen } from './screen/genderChoosingScreen';\n// eslint-disable-next-line\nimport { createGameScreen } from './screen/gameScreen';\nimport { createTestScreen } from './screen/testScreen';\n\nconst init = async () => {\n  const canvas = document.getElementById('main');\n  const info = document.getElementById('info');\n  const [width, height] = resizeCanvas(canvas, 1);\n  const gl = canvas.getContext('webgl');\n\n  const Game = {\n    width,\n    height,\n    canvas,\n    gl,\n    pixelRatio: 1,\n    setCurrentScreen(screen) {\n      if (Game.currentScreen) {\n        Game.currentScreen.destroy();\n      }\n      Game.currentScreen = screen;\n    }\n  };\n\n  Game.setCurrentScreen(await createTestScreen(Game));\n\n  gl.clearColor(1, 1, 1, 1);\n  const update = delta => {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    if (Game.currentScreen) {\n      Game.currentScreen.update(delta);\n    }\n  };\n\n  const gameLoop = createGameLoop(update);\n  setInterval(\n    () => (info.innerHTML = `FPS: ${Math.floor(gameLoop.getFps())}`),\n    1000\n  );\n};\n\ninit();\n"],"sourceRoot":""}